
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TemplateHaskell #-}

module NanoLens.MetaTH where

import Control.Applicative
import Control.Monad
import Control.Monad.State
import Data.Char
import Data.Eq
import Data.Functor
import Data.Functor.Identity
import Data.Functor.Const
import Data.Function
import Data.List
import Data.Maybe
import GHC.Int
import Text.Show

import NanoLens.Lens

import Language.Haskell.TH
import Language.Haskell.TH.Syntax
import Language.Haskell.TH.Lib



-- | All the metadata needed to derive a lens:
-- - the lens's name;
-- - the lens's targets;
-- - the original field type;
-- - the outer type.
--
-- Once we've determined the metadata, creating lenses is trivial:
--  >>> LensMeta nm [Con1 x _, Con2 _ x, ...] a s
-- expands to:
--  >>> nm :: Lens' s a                             -- (1)
--  >>>   nm k (Con1 x v) = k x <&> \y -> Con1 y v  -- (2)
--  >>>   nm k (Con2 v x) = k x <&> \y -> Con2 v y
--  >>>   ...
-- where (1) is generated by 'genLensSignature', and (2) comes
-- from mapping 'genLensClause' over all targets.
--
data LensMeta = LensMeta Name [LensTarget] Type Type

-- | For each constructor in the type we lens over, we
-- target a list of fields of that constructor.
--
data LensTarget = LensTarget Name Int [Int]

-- | Generate a lens signature of the form:
--  >>> lens :: Lens' s a
--
genLensSignature :: LensMeta -> Q Dec
genLensSignature (LensMeta nm _ originTy outerTy) = do
    sigD nm (return $ conAppsT ''Lens' [outerTy, originTy])

genLensFunction :: LensMeta -> Q Dec
genLensFunction (LensMeta nm targets _ _) = do
    funD nm $ map genLensClause targets

-- | Generate a lens clause for a single constructor:
--  >>> lens k (Con1 x v) = k x <&> \y -> Con1 y v
--
genLensClause :: LensTarget -> Q Clause
genLensClause (LensTarget conName fieldNum [nr]) = do
    kName <- newName "k"
    let kPat = varP kName
        kExp = varE kName

    vNames <- newNames "v" fieldNum
    let targetPat = conP conName $ map varP vNames
        xExp = varE $ vNames !! nr

    yName <- newName "y" 
    let yPat = varP yName
        yExps = map varE $ zipWith go [0..] vNames where
            go n v = if n == nr then yName else v

        conExp = foldl appE (conE conName) yExps
        targetLam = lamE [ yPat ] conExp

        lensBody = [| $kExp $xExp <&> $targetLam |]

    clause [ kPat, targetPat ] (normalB lensBody) []

genLensClause _ =
    fail "cannot satisfy many-indexed targets"


-- | Generate a single lens, and amend it when necessary.
-- 
genLensConnective :: LensScheme -> LensMeta -> Q [Dec]
genLensConnective scheme meta = do
    lensSig <- genLensSignature meta
    lensFun <- genLensFunction meta

    amendScheme scheme meta lensSig lensFun


-- | Any supplemental work beyond the generation of simple lenses
-- must be implemented through a scheme.
--
-- 'nameScheme' determines the names of lens functions.
-- 'amendScheme' modifies a simple lens with supplemental declarations
-- (i.e. creating instance declarations).
--
data LensScheme = LensScheme
    { amendScheme   :: AmendScheme
    , nameScheme    :: LensNameScheme }

type AmendScheme = LensMeta -> Dec -> Dec -> Q [Dec]

type LensNameScheme = Name -> Name

-- | Most basic lens creating scheme.
--
-- Given:
--  >>> data MyType
--  >>>     = Con1 { _field1 :: Field1
--  >>>            , _field2 :: Field2 }
--  >>>     | Con2 { _field1 :: Field1 }
--
-- it will generate:
--  >>> field1 :: Lens' MyType Field1
--  >>>   field1 k (Con1 x v) = k x <&> \y -> Con1 y v
--  >>>   field1 k (Con2 x) = k x <&> \y -> Con2 y
--  >>>
--  >>> field2 :: Lens' MyType Field2
--  >>>   field2 k (Con1 v x) = k x <&> \y -> Con1 v y
--
simpleScheme = LensScheme
    { amendScheme   = amendNothing
    , nameScheme    = underscoreNameScheme }
  where
    amendNothing meta sig fun = return [ sig, fun ]

-- | Class and instance generating scheme to allow lens overloading.
--
-- Given:
--  >>> data MyType
--  >>>     = Con1 { _field1 :: Field1
--  >>>            , _field2 :: Field2 }
--  >>>     | Con2 { _field1 :: Field1 }
--
-- it will generate:
--  >>> class HasField1 s a | s -> a where
--  >>>     field1 :: Lens' s a
--  >>>
--  >>> instance HasField1 MyType Field1 where
--  >>>     field1 k (Con1 x v) = k x <&> \y -> Con1 y v
--  >>>     field1 k (Con2 x) = k x <&> \y -> Con2 y
--  >>>
--  >>> class HasField2 s a | s -> a where
--  >>>     field2 :: Lens' s a
--  >>>
--  >>> instance HasField2 MyType Field2 where
--  >>>     field2 k (Con1 v x) = k x <&> \y -> Con1 v y
--
overloadScheme = LensScheme
    { amendScheme   = amendInstance
    , nameScheme    = underscoreNameScheme }
  where
    -- | Plug the lens function definition into a class instance.
    -- 
    -- Generate the class first if it's not there yet.
    --
    -- Discards the lens's signature; that comes from the instance.
    -- 
    amendInstance (LensMeta nm _ originTy outerTy) sig fun = do
        classExists <- isJust <$> lookupTypeName (show className)
        classDec <- return $ if classExists
            then []
            else [genClass className nm]
        -- ^ Don't generate a class if one already exists.
        
        let instanceTy = conAppsT className [outerTy, originTy]
        instanceDec <-
            instanceD (cxt []) (return instanceTy) [ return fun ]

        sequence $ classDec ++ [ return instanceDec ]
      where
        className = case nameBase nm of
            x:xs    -> mkName $ "Has" ++ (toUpper x:xs)
            []      -> mkName ""

    genClass className nm = do
        sName <- newName "s"
        aName <- newName "a"
        let tyVars   = [ PlainTV sName, PlainTV aName ]
            funDeps  = [ FunDep [sName] [aName] ]
            methodTy = conAppsT ''Lens' [ VarT sName, VarT aName ]
        classD (cxt []) className tyVars funDeps
            [ sigD nm (return methodTy) ]

underscoreNameScheme nm = case nameBase nm of
    '_':x:xs    -> mkName (toLower x:xs)
    _           -> mkName ""


-- | Get a list of lens metadata from a type declaration.
--
--preprocessTyForLenses :: Dec -> Q [LensMeta]
--preprocessTyForLenses (DataD _ _ tyVars _ cons _) = do
--    fields <- getFields
--    fieldMap = foldl keyField empty fields
--  where
--    keyField field@(nm, _, _) = insert nm field


-- | Apply a list of TH type arguments to a type constructor.
--
conAppsT :: Name -> [Type] -> Type
conAppsT nm = foldl AppT (ConT nm)

-- | Create a list of @n@ names.
--
newNames :: String -> Int -> Q [Name]
newNames base n =
    sequence [ newName (base ++ show i) | i <- [1..n] ]


